<?php
namespace EDAM\Types;

/**
 * Autogenerated by Thrift Compiler (0.21.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
use Thrift\Base\TBase;
use Thrift\Type\TType;
use Thrift\Type\TMessageType;
use Thrift\Exception\TException;
use Thrift\Exception\TProtocolException;
use Thrift\Protocol\TProtocol;
use Thrift\Protocol\TBinaryProtocolAccelerated;
use Thrift\Exception\TApplicationException;

/**
 * The list of optional attributes that can be stored on a note.
 * <dl>
 * <dt>subjectDate</dt>
 *   <dd>time that the note refers to
 *   </dd>
 * 
 * <dt>latitude</dt>
 *   <dd>the latitude where the note was taken
 *   </dd>
 * 
 * <dt>longitude</dt>
 *   <dd>the longitude where the note was taken
 *   </dd>
 * 
 * <dt>altitude</dt>
 *   <dd>the altitude where the note was taken
 *   </dd>
 * 
 * <dt>author</dt>
 *   <dd>the author of the content of the note
 *   <br/>
 *   Length:  EDAM_ATTRIBUTE_LEN_MIN - EDAM_ATTRIBUTE_LEN_MAX
 *   </dd>
 * 
 * <dt>source</dt>
 *   <dd>the method that the note was added to the account, if the
 *   note wasn't directly authored in an Evernote desktop client.
 *   <br/>
 *   Length:  EDAM_ATTRIBUTE_LEN_MIN - EDAM_ATTRIBUTE_LEN_MAX
 *   </dd>
 * 
 * <dt>sourceURL</dt>
 *   <dd>the original location where the resource was hosted. For web clips,
 *   this will be the URL of the page that was clipped.
 *   <br/>
 *   Length:  EDAM_ATTRIBUTE_LEN_MIN - EDAM_ATTRIBUTE_LEN_MAX
 *   </dd>
 * 
 * <dt>sourceApplication</dt>
 *   <dd>an identifying string for the application that
 *   created this note.  This string does not have a guaranteed syntax or
 *   structure -- it is intended for human inspection and tracking.
 *   <br/>
 *   Length:  EDAM_ATTRIBUTE_LEN_MIN - EDAM_ATTRIBUTE_LEN_MAX
 *   </dd>
 * 
 * <dt>shareDate</dt>
 *  <dd>The date and time when this note was directly shared via its own URL.
 *  This is only set on notes that were individually shared - it is independent
 *  of any notebook-level sharing of the containing notebook. This field
 *  is treated as "read-only" for clients; the server will ignore changes
 *  to this field from an external client.
 *  </dd>
 * 
 * <dt>reminderOrder</dt>
 * <dd>The set of notes with this parameter set are considered
 * "reminders" and are to be treated specially by clients to give them
 * higher UI prominence within a notebook.  The value is used to sort
 * the reminder notes within the notebook with higher values
 * representing greater prominence.  Outside of the context of a
 * notebook, the value of this parameter is undefined.  The value is
 * not intended to be compared to the values of reminder notes in
 * other notebooks.  In order to allow clients to place a note at a
 * higher precedence than other notes, you should never set a value
 * greater than the current time (as defined for a Timetstamp). To
 * place a note at higher precedence than existing notes, set the
 * value to the current time as defined for a timestamp (milliseconds
 * since the epoch).  Synchronizing clients must remember the time when
 * the update was performed, using the local clock on the client,
 * and use that value when they later upload the note to the service.
 * Clients must not set the reminderOrder to the reminderTime as the
 * reminderTime could be in the future.  Those two fields are never
 * intended to be related.  The correct value for reminderOrder field
 * for new notes is the "current" time when the user indicated that
 * the note is a reminder.  Clients may implement a separate
 * "sort by date" feature to show notes ordered by reminderTime.
 * Whenever a reminderDoneTime or reminderTime is set but a
 * reminderOrder is not set, the server will fill in the current
 * server time for the reminderOrder field.</dd>
 * 
 * <dt>reminderDoneTime</dt>
 * <dd>The date and time when a user dismissed/"marked done" the reminder
 * on the note.  Users typically do not manually set this value directly
 * as it is set to the time when the user dismissed/"marked done" the
 * reminder.</dd>
 * 
 * <dt>reminderTime</dt>
 * <dd>The date and time a user has selected to be reminded of the note.
 * A note with this value set is known as a "reminder" and the user can
 * be reminded, via e-mail or client-specific notifications, of the note
 * when the time is reached or about to be reached.  When a user sets
 * a reminder time on a note that has a reminder done time, and that
 * reminder time is in the future, then the reminder done time should be
 * cleared.  This should happen regardless of any existing reminder time
 * that may have previously existed on the note.</dd>
 * 
 * <dt>placeName</dt>
 * <dd>Allows the user to assign a human-readable location name associated
 * with a note. Users may assign values like 'Home' and 'Work'. Place
 * names may also be populated with values from geonames database
 * (e.g., a restaurant name). Applications are encouraged to normalize values
 * so that grouping values by place name provides a useful result. Applications
 * MUST NOT automatically add place name values based on geolocation without
 * confirmation from the user; that is, the value in this field should be
 * more useful than a simple automated lookup based on the note's latitude
 * and longitude.</dd>
 * 
 * <dt>contentClass</dt>
 * <dd>The class (or type) of note. This field is used to indicate to
 * clients that special structured information is represented within
 * the note such that special rules apply when making
 * modifications. If contentClass is set and the client
 * application does not specifically support the specified class,
 * the client MUST treat the note as read-only. In this case, the
 * client MAY modify the note's notebook and tags via the
 * Note.notebookGuid and Note.tagGuids fields.  The client MAY also
 * modify the reminderOrder field as well as the reminderTime and
 * reminderDoneTime fields.
 * <p>Applications should set contentClass only when they are creating notes
 * that contain structured information that needs to be maintained in order
 * for the user to be able to use the note within that application.
 * Setting contentClass makes a note read-only in other applications, so
 * there is a trade-off when an application chooses to use contentClass.
 * Applications that set contentClass when creating notes must use a contentClass
 * string of the form <i>CompanyName.ApplicationName</i> to ensure uniqueness.</p>
 * Length restrictions: EDAM_NOTE_CONTENT_CLASS_LEN_MIN, EDAM_NOTE_CONTENT_CLASS_LEN_MAX
 * <br/>
 * Regex: EDAM_NOTE_CONTENT_CLASS_REGEX
 * </dd>
 * 
 * <dt>applicationData</dt>
 * <dd>Provides a location for applications to store a relatively small
 * (4kb) blob of data that is not meant to be visible to the user and
 * that is opaque to the Evernote service. A single application may use at most
 * one entry in this map, using its API consumer key as the map key. See the
 * documentation for LazyMap for a description of when the actual map values
 * are returned by the service.
 * <p>To safely add or modify your application's entry in the map, use
 * NoteStore.setNoteApplicationDataEntry. To safely remove your application's
 * entry from the map, use NoteStore.unsetNoteApplicationDataEntry.</p>
 * Minimum length of a name (key): EDAM_APPLICATIONDATA_NAME_LEN_MIN
 * <br/>
 * Sum max size of key and value: EDAM_APPLICATIONDATA_ENTRY_LEN_MAX
 * <br/>
 * Syntax regex for name (key): EDAM_APPLICATIONDATA_NAME_REGEX
 * </dd>
 * 
 * <dt>creatorId</dt>
 * <dd>The numeric user ID of the user who originally created the note.</dd>
 * 
 * <dt>lastEditedBy</dt>
 * <dd>An indication of who made the last change to the note.  If you are
 * accessing the note via a shared notebook to which you have modification
 * rights, or if you are the owner of the notebook to which the note belongs,
 * then you have access to the value.  In this case, the value will be
 * unset if the owner of the notebook containing the note was the last to
 * make the modification, else it will be a string describing the
 * guest who made the last edit.  If you do not have access to this value,
 * it will be left unset.  This field is read-only by clients.  The server
 * will ignore all values set by clients into this field.</dd>
 * 
 * <dt>lastEditorId</dt>
 * <dd>The numeric user ID of the user described in lastEditedBy.</dd>
 * 
 * <dt>classifications</dt>
 * <dd>A map of classifications applied to the note by clients or by the
 * Evernote service. The key is the string name of the classification type,
 * and the value is a constant that begins with CLASSIFICATION_.</dd>
 * 
 * <dt>sharedWithBusiness</dt>
 * <dd>When this flag is set on a business note, any user in that business
 * may view the note if they request it by GUID. This field is read-only by
 * clients. The server will ignore all values set by clients into this field.
 * 
 * To share a note with the business, use NoteStore.shareNoteWithBusiness and
 * to stop sharing a note with the business, use NoteStore.stopSharingNoteWithBusiness.
 * </dd>
 * 
 * <dt>conflictSourceNoteGuid</dt>
 * <dd>If set, this specifies the GUID of a note that caused a sync conflict
 * resulting in the creation of a duplicate note. The duplicated note contains
 * the user's changes that could not be applied as a result of the sync conflict,
 * and uses the conflictSourceNoteGuid field to specify the note that caused the
 * conflict. This allows clients to provide a customized user experience for note
 * conflicts.
 * </dd>
 * 
 * <dt>noteTitleQuality</dt>
 * <dd>If set, this specifies that the note's title was automatically generated
 * and indicates the likelihood that the generated title is useful for display to
 * the user. If not set, the note's title was manually entered by the user.
 * 
 * Clients MUST set this attribute to one of the following values when the
 * corresponding note's title was not manually entered by the user:
 * EDAM_NOTE_TITLE_QUALITY_UNTITLED, EDAM_NOTE_TITLE_QUALITY_LOW,
 * EDAM_NOTE_TITLE_QUALITY_MEDIUM or EDAM_NOTE_TITLE_QUALITY_HIGH.
 * 
 * When a user edits a note's title, clients MUST unset this value.
 * </dd>
 * </dl>
 */
class NoteAttributes
{
    static public $isValidate = false;

    static public $_TSPEC = array(
        1 => array(
            'var' => 'subjectDate',
            'isRequired' => false,
            'type' => TType::I64,
        ),
        10 => array(
            'var' => 'latitude',
            'isRequired' => false,
            'type' => TType::DOUBLE,
        ),
        11 => array(
            'var' => 'longitude',
            'isRequired' => false,
            'type' => TType::DOUBLE,
        ),
        12 => array(
            'var' => 'altitude',
            'isRequired' => false,
            'type' => TType::DOUBLE,
        ),
        13 => array(
            'var' => 'author',
            'isRequired' => false,
            'type' => TType::STRING,
        ),
        14 => array(
            'var' => 'source',
            'isRequired' => false,
            'type' => TType::STRING,
        ),
        15 => array(
            'var' => 'sourceURL',
            'isRequired' => false,
            'type' => TType::STRING,
        ),
        16 => array(
            'var' => 'sourceApplication',
            'isRequired' => false,
            'type' => TType::STRING,
        ),
        17 => array(
            'var' => 'shareDate',
            'isRequired' => false,
            'type' => TType::I64,
        ),
        18 => array(
            'var' => 'reminderOrder',
            'isRequired' => false,
            'type' => TType::I64,
        ),
        19 => array(
            'var' => 'reminderDoneTime',
            'isRequired' => false,
            'type' => TType::I64,
        ),
        20 => array(
            'var' => 'reminderTime',
            'isRequired' => false,
            'type' => TType::I64,
        ),
        21 => array(
            'var' => 'placeName',
            'isRequired' => false,
            'type' => TType::STRING,
        ),
        22 => array(
            'var' => 'contentClass',
            'isRequired' => false,
            'type' => TType::STRING,
        ),
        23 => array(
            'var' => 'applicationData',
            'isRequired' => false,
            'type' => TType::STRUCT,
            'class' => '\EDAM\Types\LazyMap',
        ),
        24 => array(
            'var' => 'lastEditedBy',
            'isRequired' => false,
            'type' => TType::STRING,
        ),
        26 => array(
            'var' => 'classifications',
            'isRequired' => false,
            'type' => TType::MAP,
            'ktype' => TType::STRING,
            'vtype' => TType::STRING,
            'key' => array(
                'type' => TType::STRING,
            ),
            'val' => array(
                'type' => TType::STRING,
                ),
        ),
        27 => array(
            'var' => 'creatorId',
            'isRequired' => false,
            'type' => TType::I32,
        ),
        28 => array(
            'var' => 'lastEditorId',
            'isRequired' => false,
            'type' => TType::I32,
        ),
        29 => array(
            'var' => 'sharedWithBusiness',
            'isRequired' => false,
            'type' => TType::BOOL,
        ),
        30 => array(
            'var' => 'conflictSourceNoteGuid',
            'isRequired' => false,
            'type' => TType::STRING,
        ),
        31 => array(
            'var' => 'noteTitleQuality',
            'isRequired' => false,
            'type' => TType::I32,
        ),
    );

    /**
     * @var int
     */
    public $subjectDate = null;
    /**
     * @var double
     */
    public $latitude = null;
    /**
     * @var double
     */
    public $longitude = null;
    /**
     * @var double
     */
    public $altitude = null;
    /**
     * @var string
     */
    public $author = null;
    /**
     * @var string
     */
    public $source = null;
    /**
     * @var string
     */
    public $sourceURL = null;
    /**
     * @var string
     */
    public $sourceApplication = null;
    /**
     * @var int
     */
    public $shareDate = null;
    /**
     * @var int
     */
    public $reminderOrder = null;
    /**
     * @var int
     */
    public $reminderDoneTime = null;
    /**
     * @var int
     */
    public $reminderTime = null;
    /**
     * @var string
     */
    public $placeName = null;
    /**
     * @var string
     */
    public $contentClass = null;
    /**
     * @var \EDAM\Types\LazyMap
     */
    public $applicationData = null;
    /**
     * @var string
     */
    public $lastEditedBy = null;
    /**
     * @var array
     */
    public $classifications = null;
    /**
     * @var int
     */
    public $creatorId = null;
    /**
     * @var int
     */
    public $lastEditorId = null;
    /**
     * @var bool
     */
    public $sharedWithBusiness = null;
    /**
     * @var string
     */
    public $conflictSourceNoteGuid = null;
    /**
     * @var int
     */
    public $noteTitleQuality = null;

    public function __construct($vals = null)
    {
        if (is_array($vals)) {
            if (isset($vals['subjectDate'])) {
                $this->subjectDate = $vals['subjectDate'];
            }
            if (isset($vals['latitude'])) {
                $this->latitude = $vals['latitude'];
            }
            if (isset($vals['longitude'])) {
                $this->longitude = $vals['longitude'];
            }
            if (isset($vals['altitude'])) {
                $this->altitude = $vals['altitude'];
            }
            if (isset($vals['author'])) {
                $this->author = $vals['author'];
            }
            if (isset($vals['source'])) {
                $this->source = $vals['source'];
            }
            if (isset($vals['sourceURL'])) {
                $this->sourceURL = $vals['sourceURL'];
            }
            if (isset($vals['sourceApplication'])) {
                $this->sourceApplication = $vals['sourceApplication'];
            }
            if (isset($vals['shareDate'])) {
                $this->shareDate = $vals['shareDate'];
            }
            if (isset($vals['reminderOrder'])) {
                $this->reminderOrder = $vals['reminderOrder'];
            }
            if (isset($vals['reminderDoneTime'])) {
                $this->reminderDoneTime = $vals['reminderDoneTime'];
            }
            if (isset($vals['reminderTime'])) {
                $this->reminderTime = $vals['reminderTime'];
            }
            if (isset($vals['placeName'])) {
                $this->placeName = $vals['placeName'];
            }
            if (isset($vals['contentClass'])) {
                $this->contentClass = $vals['contentClass'];
            }
            if (isset($vals['applicationData'])) {
                $this->applicationData = $vals['applicationData'];
            }
            if (isset($vals['lastEditedBy'])) {
                $this->lastEditedBy = $vals['lastEditedBy'];
            }
            if (isset($vals['classifications'])) {
                $this->classifications = $vals['classifications'];
            }
            if (isset($vals['creatorId'])) {
                $this->creatorId = $vals['creatorId'];
            }
            if (isset($vals['lastEditorId'])) {
                $this->lastEditorId = $vals['lastEditorId'];
            }
            if (isset($vals['sharedWithBusiness'])) {
                $this->sharedWithBusiness = $vals['sharedWithBusiness'];
            }
            if (isset($vals['conflictSourceNoteGuid'])) {
                $this->conflictSourceNoteGuid = $vals['conflictSourceNoteGuid'];
            }
            if (isset($vals['noteTitleQuality'])) {
                $this->noteTitleQuality = $vals['noteTitleQuality'];
            }
        }
    }

    public function getName()
    {
        return 'NoteAttributes';
    }


    public function read($input)
    {
        $xfer = 0;
        $fname = null;
        $ftype = 0;
        $fid = 0;
        $xfer += $input->readStructBegin($fname);
        while (true) {
            $xfer += $input->readFieldBegin($fname, $ftype, $fid);
            if ($ftype == TType::STOP) {
                break;
            }
            switch ($fid) {
                case 1:
                    if ($ftype == TType::I64) {
                        $xfer += $input->readI64($this->subjectDate);
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 10:
                    if ($ftype == TType::DOUBLE) {
                        $xfer += $input->readDouble($this->latitude);
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 11:
                    if ($ftype == TType::DOUBLE) {
                        $xfer += $input->readDouble($this->longitude);
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 12:
                    if ($ftype == TType::DOUBLE) {
                        $xfer += $input->readDouble($this->altitude);
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 13:
                    if ($ftype == TType::STRING) {
                        $xfer += $input->readString($this->author);
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 14:
                    if ($ftype == TType::STRING) {
                        $xfer += $input->readString($this->source);
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 15:
                    if ($ftype == TType::STRING) {
                        $xfer += $input->readString($this->sourceURL);
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 16:
                    if ($ftype == TType::STRING) {
                        $xfer += $input->readString($this->sourceApplication);
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 17:
                    if ($ftype == TType::I64) {
                        $xfer += $input->readI64($this->shareDate);
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 18:
                    if ($ftype == TType::I64) {
                        $xfer += $input->readI64($this->reminderOrder);
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 19:
                    if ($ftype == TType::I64) {
                        $xfer += $input->readI64($this->reminderDoneTime);
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 20:
                    if ($ftype == TType::I64) {
                        $xfer += $input->readI64($this->reminderTime);
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 21:
                    if ($ftype == TType::STRING) {
                        $xfer += $input->readString($this->placeName);
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 22:
                    if ($ftype == TType::STRING) {
                        $xfer += $input->readString($this->contentClass);
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 23:
                    if ($ftype == TType::STRUCT) {
                        $this->applicationData = new \EDAM\Types\LazyMap();
                        $xfer += $this->applicationData->read($input);
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 24:
                    if ($ftype == TType::STRING) {
                        $xfer += $input->readString($this->lastEditedBy);
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 26:
                    if ($ftype == TType::MAP) {
                        $this->classifications = array();
                        $_size31 = 0;
                        $_ktype32 = 0;
                        $_vtype33 = 0;
                        $xfer += $input->readMapBegin($_ktype32, $_vtype33, $_size31);
                        for ($_i35 = 0; $_i35 < $_size31; ++$_i35) {
                            $key36 = '';
                            $val37 = '';
                            $xfer += $input->readString($key36);
                            $xfer += $input->readString($val37);
                            $this->classifications[$key36] = $val37;
                        }
                        $xfer += $input->readMapEnd();
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 27:
                    if ($ftype == TType::I32) {
                        $xfer += $input->readI32($this->creatorId);
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 28:
                    if ($ftype == TType::I32) {
                        $xfer += $input->readI32($this->lastEditorId);
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 29:
                    if ($ftype == TType::BOOL) {
                        $xfer += $input->readBool($this->sharedWithBusiness);
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 30:
                    if ($ftype == TType::STRING) {
                        $xfer += $input->readString($this->conflictSourceNoteGuid);
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 31:
                    if ($ftype == TType::I32) {
                        $xfer += $input->readI32($this->noteTitleQuality);
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                default:
                    $xfer += $input->skip($ftype);
                    break;
            }
            $xfer += $input->readFieldEnd();
        }
        $xfer += $input->readStructEnd();
        return $xfer;
    }

    public function write($output)
    {
        $xfer = 0;
        $xfer += $output->writeStructBegin('NoteAttributes');
        if ($this->subjectDate !== null) {
            $xfer += $output->writeFieldBegin('subjectDate', TType::I64, 1);
            $xfer += $output->writeI64($this->subjectDate);
            $xfer += $output->writeFieldEnd();
        }
        if ($this->latitude !== null) {
            $xfer += $output->writeFieldBegin('latitude', TType::DOUBLE, 10);
            $xfer += $output->writeDouble($this->latitude);
            $xfer += $output->writeFieldEnd();
        }
        if ($this->longitude !== null) {
            $xfer += $output->writeFieldBegin('longitude', TType::DOUBLE, 11);
            $xfer += $output->writeDouble($this->longitude);
            $xfer += $output->writeFieldEnd();
        }
        if ($this->altitude !== null) {
            $xfer += $output->writeFieldBegin('altitude', TType::DOUBLE, 12);
            $xfer += $output->writeDouble($this->altitude);
            $xfer += $output->writeFieldEnd();
        }
        if ($this->author !== null) {
            $xfer += $output->writeFieldBegin('author', TType::STRING, 13);
            $xfer += $output->writeString($this->author);
            $xfer += $output->writeFieldEnd();
        }
        if ($this->source !== null) {
            $xfer += $output->writeFieldBegin('source', TType::STRING, 14);
            $xfer += $output->writeString($this->source);
            $xfer += $output->writeFieldEnd();
        }
        if ($this->sourceURL !== null) {
            $xfer += $output->writeFieldBegin('sourceURL', TType::STRING, 15);
            $xfer += $output->writeString($this->sourceURL);
            $xfer += $output->writeFieldEnd();
        }
        if ($this->sourceApplication !== null) {
            $xfer += $output->writeFieldBegin('sourceApplication', TType::STRING, 16);
            $xfer += $output->writeString($this->sourceApplication);
            $xfer += $output->writeFieldEnd();
        }
        if ($this->shareDate !== null) {
            $xfer += $output->writeFieldBegin('shareDate', TType::I64, 17);
            $xfer += $output->writeI64($this->shareDate);
            $xfer += $output->writeFieldEnd();
        }
        if ($this->reminderOrder !== null) {
            $xfer += $output->writeFieldBegin('reminderOrder', TType::I64, 18);
            $xfer += $output->writeI64($this->reminderOrder);
            $xfer += $output->writeFieldEnd();
        }
        if ($this->reminderDoneTime !== null) {
            $xfer += $output->writeFieldBegin('reminderDoneTime', TType::I64, 19);
            $xfer += $output->writeI64($this->reminderDoneTime);
            $xfer += $output->writeFieldEnd();
        }
        if ($this->reminderTime !== null) {
            $xfer += $output->writeFieldBegin('reminderTime', TType::I64, 20);
            $xfer += $output->writeI64($this->reminderTime);
            $xfer += $output->writeFieldEnd();
        }
        if ($this->placeName !== null) {
            $xfer += $output->writeFieldBegin('placeName', TType::STRING, 21);
            $xfer += $output->writeString($this->placeName);
            $xfer += $output->writeFieldEnd();
        }
        if ($this->contentClass !== null) {
            $xfer += $output->writeFieldBegin('contentClass', TType::STRING, 22);
            $xfer += $output->writeString($this->contentClass);
            $xfer += $output->writeFieldEnd();
        }
        if ($this->applicationData !== null) {
            if (!is_object($this->applicationData)) {
                throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
            }
            $xfer += $output->writeFieldBegin('applicationData', TType::STRUCT, 23);
            $xfer += $this->applicationData->write($output);
            $xfer += $output->writeFieldEnd();
        }
        if ($this->lastEditedBy !== null) {
            $xfer += $output->writeFieldBegin('lastEditedBy', TType::STRING, 24);
            $xfer += $output->writeString($this->lastEditedBy);
            $xfer += $output->writeFieldEnd();
        }
        if ($this->classifications !== null) {
            if (!is_array($this->classifications)) {
                throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
            }
            $xfer += $output->writeFieldBegin('classifications', TType::MAP, 26);
            $output->writeMapBegin(TType::STRING, TType::STRING, count($this->classifications));
            foreach ($this->classifications as $kiter38 => $viter39) {
                $xfer += $output->writeString($kiter38);
                $xfer += $output->writeString($viter39);
            }
            $output->writeMapEnd();
            $xfer += $output->writeFieldEnd();
        }
        if ($this->creatorId !== null) {
            $xfer += $output->writeFieldBegin('creatorId', TType::I32, 27);
            $xfer += $output->writeI32($this->creatorId);
            $xfer += $output->writeFieldEnd();
        }
        if ($this->lastEditorId !== null) {
            $xfer += $output->writeFieldBegin('lastEditorId', TType::I32, 28);
            $xfer += $output->writeI32($this->lastEditorId);
            $xfer += $output->writeFieldEnd();
        }
        if ($this->sharedWithBusiness !== null) {
            $xfer += $output->writeFieldBegin('sharedWithBusiness', TType::BOOL, 29);
            $xfer += $output->writeBool($this->sharedWithBusiness);
            $xfer += $output->writeFieldEnd();
        }
        if ($this->conflictSourceNoteGuid !== null) {
            $xfer += $output->writeFieldBegin('conflictSourceNoteGuid', TType::STRING, 30);
            $xfer += $output->writeString($this->conflictSourceNoteGuid);
            $xfer += $output->writeFieldEnd();
        }
        if ($this->noteTitleQuality !== null) {
            $xfer += $output->writeFieldBegin('noteTitleQuality', TType::I32, 31);
            $xfer += $output->writeI32($this->noteTitleQuality);
            $xfer += $output->writeFieldEnd();
        }
        $xfer += $output->writeFieldStop();
        $xfer += $output->writeStructEnd();
        return $xfer;
    }
}

<?php
namespace EDAM\Types;

/**
 * Autogenerated by Thrift Compiler (0.21.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
use Thrift\Base\TBase;
use Thrift\Type\TType;
use Thrift\Type\TMessageType;
use Thrift\Exception\TException;
use Thrift\Exception\TProtocolException;
use Thrift\Protocol\TProtocol;
use Thrift\Protocol\TBinaryProtocolAccelerated;
use Thrift\Exception\TApplicationException;

/**
 * Represents a single note in the user's account.
 * 
 * <dl>
 * <dt>guid</dt>
 *   <dd>The unique identifier of this note.  Will be set by the
 *   server, but will be omitted by clients calling NoteStore.createNote()
 *   <br/>
 *   Length:  EDAM_GUID_LEN_MIN - EDAM_GUID_LEN_MAX
 *   <br/>
 *   Regex:  EDAM_GUID_REGEX
 *   </dd>
 * 
 * <dt>title</dt>
 *   <dd>The subject of the note.  Can't begin or end with a space.
 *   <br/>
 *   Length:  EDAM_NOTE_TITLE_LEN_MIN - EDAM_NOTE_TITLE_LEN_MAX
 *   <br/>
 *   Regex:  EDAM_NOTE_TITLE_REGEX
 *   </dd>
 * 
 * <dt>content</dt>
 *   <dd>The XHTML block that makes up the note.  This is
 *   the canonical form of the note's contents, so will include abstract
 *   Evernote tags for internal resource references.  A client may create
 *   a separate transformed version of this content for internal presentation,
 *   but the same canonical bytes should be used for transmission and
 *   comparison unless the user chooses to modify their content.
 *   <br/>
 *   Length:  EDAM_NOTE_CONTENT_LEN_MIN - EDAM_NOTE_CONTENT_LEN_MAX
 *   </dd>
 * 
 * <dt>contentHash</dt>
 *   <dd>The binary MD5 checksum of the UTF-8 encoded content
 *   body. This will always be set by the server, but clients may choose to omit
 *   this when they submit a note with content.
 *   <br/>
 *   Length:  EDAM_HASH_LEN (exactly)
 *   </dd>
 * 
 * <dt>contentLength</dt>
 *   <dd>The number of Unicode characters in the content of
 *   the note.  This will always be set by the service, but clients may choose
 *   to omit this value when they submit a Note.
 *   </dd>
 * 
 * <dt>created</dt>
 *   <dd>The date and time when the note was created in one of the
 *   clients.  In most cases, this will match the user's sense of when
 *   the note was created, and ordering between notes will be based on
 *   ordering of this field.  However, this is not a "reliable" timestamp
 *   if a client has an incorrect clock, so it cannot provide a true absolute
 *   ordering between notes.  Notes created directly through the service
 *   (e.g. via the web GUI) will have an absolutely ordered "created" value.
 *   </dd>
 * 
 * <dt>updated</dt>
 *   <dd>The date and time when the note was last modified in one of
 *   the clients.  In most cases, this will match the user's sense of when
 *   the note was modified, but this field may not be absolutely reliable
 *   due to the possibility of client clock errors.
 *   </dd>
 * 
 * <dt>deleted</dt>
 *   <dd>If present, the note is considered "deleted", and this
 *   stores the date and time when the note was deleted by one of the clients.
 *   In most cases, this will match the user's sense of when the note was
 *   deleted, but this field may be unreliable due to the possibility of
 *   client clock errors.
 *   </dd>
 * 
 * <dt>active</dt>
 *   <dd>If the note is available for normal actions and viewing,
 *   this flag will be set to true.
 *   </dd>
 * 
 * <dt>updateSequenceNum</dt>
 *   <dd>A number identifying the last transaction to
 *   modify the state of this note (including changes to the note's attributes
 *   or resources).  The USN values are sequential within an account,
 *   and can be used to compare the order of modifications within the service.
 *   </dd>
 * 
 * <dt>notebookGuid</dt>
 *   <dd>The unique identifier of the notebook that contains
 *   this note.  If no notebookGuid is provided on a call to createNote(), the
 *   default notebook will be used instead.
 *   <br/>
 *   Length:  EDAM_GUID_LEN_MIN - EDAM_GUID_LEN_MAX
 *   <br/>
 *   Regex:  EDAM_GUID_REGEX
 *   </dd>
 * 
 * <dt>tagGuids</dt>
 *   <dd>A list of the GUID identifiers for tags that are applied to this note.
 *   This may be provided in a call to createNote() to unambiguously declare
 *   the tags that should be assigned to the new note.  Alternately, clients
 *   may pass the names of desired tags via the 'tagNames' field during
 *   note creation.
 *   If the list of tags are omitted on a call to createNote(), then
 *   the server will assume that no changes have been made to the resources.
 *   Maximum:  EDAM_NOTE_TAGS_MAX tags per note
 *   </dd>
 * 
 * <dt>resources</dt>
 *   <dd>The list of resources that are embedded within this note.
 *   If the list of resources are omitted on a call to updateNote(), then
 *   the server will assume that no changes have been made to the resources.
 *   The binary contents of the resources must be provided when the resource
 *   is first sent to the service, but it will be omitted by the service when
 *   the Note is returned in the future.
 *   Maximum:  EDAM_NOTE_RESOURCES_MAX resources per note
 *   </dd>
 * 
 * <dt>attributes</dt>
 *   <dd>A list of the attributes for this note.
 *   If the list of attributes are omitted on a call to updateNote(), then
 *   the server will assume that no changes have been made to the resources.
 *   </dd>
 * 
 * <dt>tagNames</dt>
 *   <dd>May be provided by clients during calls to createNote() as an
 *   alternative to providing the tagGuids of existing tags.  If any tagNames
 *   are provided during createNote(), these will be found, or created if they
 *   don't already exist.  Created tags will have no parent (they will be at
 *   the top level of the tag panel).
 *   </dd>
 * 
 * <dt>sharedNotes</dt>
 *   <dd>The list of recipients with whom this note has been shared. This field will be unset if
 *     the caller has access to the note via the containing notebook, but does not have activity
 *     feed permission for that notebook. This field is read-only. Clients may not make changes to
 *     a note's sharing state via this field.
 *   </dd>
 * 
 *   <dt>restrictions</dt>
 *   <dd>If this field is set, the user has note-level permissions that may differ from their
 *     notebook-level permissions. In this case, the restrictions structure specifies
 *     a set of restrictions limiting the actions that a user may take on the note based
 *     on their note-level permissions. If this field is unset, then there are no
 *     note-specific restrictions. However, a client may still be limited based on the user's
 *     notebook permissions.</dd>
 * </dl>
 */
class Note
{
    static public $isValidate = false;

    static public $_TSPEC = array(
        1 => array(
            'var' => 'guid',
            'isRequired' => false,
            'type' => TType::STRING,
        ),
        2 => array(
            'var' => 'title',
            'isRequired' => false,
            'type' => TType::STRING,
        ),
        3 => array(
            'var' => 'content',
            'isRequired' => false,
            'type' => TType::STRING,
        ),
        4 => array(
            'var' => 'contentHash',
            'isRequired' => false,
            'type' => TType::STRING,
        ),
        5 => array(
            'var' => 'contentLength',
            'isRequired' => false,
            'type' => TType::I32,
        ),
        6 => array(
            'var' => 'created',
            'isRequired' => false,
            'type' => TType::I64,
        ),
        7 => array(
            'var' => 'updated',
            'isRequired' => false,
            'type' => TType::I64,
        ),
        8 => array(
            'var' => 'deleted',
            'isRequired' => false,
            'type' => TType::I64,
        ),
        9 => array(
            'var' => 'active',
            'isRequired' => false,
            'type' => TType::BOOL,
        ),
        10 => array(
            'var' => 'updateSequenceNum',
            'isRequired' => false,
            'type' => TType::I32,
        ),
        11 => array(
            'var' => 'notebookGuid',
            'isRequired' => false,
            'type' => TType::STRING,
        ),
        12 => array(
            'var' => 'tagGuids',
            'isRequired' => false,
            'type' => TType::LST,
            'etype' => TType::STRING,
            'elem' => array(
                'type' => TType::STRING,
                ),
        ),
        13 => array(
            'var' => 'resources',
            'isRequired' => false,
            'type' => TType::LST,
            'etype' => TType::STRUCT,
            'elem' => array(
                'type' => TType::STRUCT,
                'class' => '\EDAM\Types\Resource',
                ),
        ),
        14 => array(
            'var' => 'attributes',
            'isRequired' => false,
            'type' => TType::STRUCT,
            'class' => '\EDAM\Types\NoteAttributes',
        ),
        15 => array(
            'var' => 'tagNames',
            'isRequired' => false,
            'type' => TType::LST,
            'etype' => TType::STRING,
            'elem' => array(
                'type' => TType::STRING,
                ),
        ),
        16 => array(
            'var' => 'sharedNotes',
            'isRequired' => false,
            'type' => TType::LST,
            'etype' => TType::STRUCT,
            'elem' => array(
                'type' => TType::STRUCT,
                'class' => '\EDAM\Types\SharedNote',
                ),
        ),
        17 => array(
            'var' => 'restrictions',
            'isRequired' => false,
            'type' => TType::STRUCT,
            'class' => '\EDAM\Types\NoteRestrictions',
        ),
        18 => array(
            'var' => 'limits',
            'isRequired' => false,
            'type' => TType::STRUCT,
            'class' => '\EDAM\Types\NoteLimits',
        ),
    );

    /**
     * @var string
     */
    public $guid = null;
    /**
     * @var string
     */
    public $title = null;
    /**
     * @var string
     */
    public $content = null;
    /**
     * @var string
     */
    public $contentHash = null;
    /**
     * @var int
     */
    public $contentLength = null;
    /**
     * @var int
     */
    public $created = null;
    /**
     * @var int
     */
    public $updated = null;
    /**
     * @var int
     */
    public $deleted = null;
    /**
     * @var bool
     */
    public $active = null;
    /**
     * @var int
     */
    public $updateSequenceNum = null;
    /**
     * @var string
     */
    public $notebookGuid = null;
    /**
     * @var string[]
     */
    public $tagGuids = null;
    /**
     * @var \EDAM\Types\Resource[]
     */
    public $resources = null;
    /**
     * @var \EDAM\Types\NoteAttributes
     */
    public $attributes = null;
    /**
     * @var string[]
     */
    public $tagNames = null;
    /**
     * @var \EDAM\Types\SharedNote[]
     */
    public $sharedNotes = null;
    /**
     * @var \EDAM\Types\NoteRestrictions
     */
    public $restrictions = null;
    /**
     * @var \EDAM\Types\NoteLimits
     */
    public $limits = null;

    public function __construct($vals = null)
    {
        if (is_array($vals)) {
            if (isset($vals['guid'])) {
                $this->guid = $vals['guid'];
            }
            if (isset($vals['title'])) {
                $this->title = $vals['title'];
            }
            if (isset($vals['content'])) {
                $this->content = $vals['content'];
            }
            if (isset($vals['contentHash'])) {
                $this->contentHash = $vals['contentHash'];
            }
            if (isset($vals['contentLength'])) {
                $this->contentLength = $vals['contentLength'];
            }
            if (isset($vals['created'])) {
                $this->created = $vals['created'];
            }
            if (isset($vals['updated'])) {
                $this->updated = $vals['updated'];
            }
            if (isset($vals['deleted'])) {
                $this->deleted = $vals['deleted'];
            }
            if (isset($vals['active'])) {
                $this->active = $vals['active'];
            }
            if (isset($vals['updateSequenceNum'])) {
                $this->updateSequenceNum = $vals['updateSequenceNum'];
            }
            if (isset($vals['notebookGuid'])) {
                $this->notebookGuid = $vals['notebookGuid'];
            }
            if (isset($vals['tagGuids'])) {
                $this->tagGuids = $vals['tagGuids'];
            }
            if (isset($vals['resources'])) {
                $this->resources = $vals['resources'];
            }
            if (isset($vals['attributes'])) {
                $this->attributes = $vals['attributes'];
            }
            if (isset($vals['tagNames'])) {
                $this->tagNames = $vals['tagNames'];
            }
            if (isset($vals['sharedNotes'])) {
                $this->sharedNotes = $vals['sharedNotes'];
            }
            if (isset($vals['restrictions'])) {
                $this->restrictions = $vals['restrictions'];
            }
            if (isset($vals['limits'])) {
                $this->limits = $vals['limits'];
            }
        }
    }

    public function getName()
    {
        return 'Note';
    }


    public function read($input)
    {
        $xfer = 0;
        $fname = null;
        $ftype = 0;
        $fid = 0;
        $xfer += $input->readStructBegin($fname);
        while (true) {
            $xfer += $input->readFieldBegin($fname, $ftype, $fid);
            if ($ftype == TType::STOP) {
                break;
            }
            switch ($fid) {
                case 1:
                    if ($ftype == TType::STRING) {
                        $xfer += $input->readString($this->guid);
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 2:
                    if ($ftype == TType::STRING) {
                        $xfer += $input->readString($this->title);
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 3:
                    if ($ftype == TType::STRING) {
                        $xfer += $input->readString($this->content);
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 4:
                    if ($ftype == TType::STRING) {
                        $xfer += $input->readString($this->contentHash);
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 5:
                    if ($ftype == TType::I32) {
                        $xfer += $input->readI32($this->contentLength);
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 6:
                    if ($ftype == TType::I64) {
                        $xfer += $input->readI64($this->created);
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 7:
                    if ($ftype == TType::I64) {
                        $xfer += $input->readI64($this->updated);
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 8:
                    if ($ftype == TType::I64) {
                        $xfer += $input->readI64($this->deleted);
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 9:
                    if ($ftype == TType::BOOL) {
                        $xfer += $input->readBool($this->active);
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 10:
                    if ($ftype == TType::I32) {
                        $xfer += $input->readI32($this->updateSequenceNum);
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 11:
                    if ($ftype == TType::STRING) {
                        $xfer += $input->readString($this->notebookGuid);
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 12:
                    if ($ftype == TType::LST) {
                        $this->tagGuids = array();
                        $_size40 = 0;
                        $_etype43 = 0;
                        $xfer += $input->readListBegin($_etype43, $_size40);
                        for ($_i44 = 0; $_i44 < $_size40; ++$_i44) {
                            $elem45 = null;
                            $xfer += $input->readString($elem45);
                            $this->tagGuids []= $elem45;
                        }
                        $xfer += $input->readListEnd();
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 13:
                    if ($ftype == TType::LST) {
                        $this->resources = array();
                        $_size46 = 0;
                        $_etype49 = 0;
                        $xfer += $input->readListBegin($_etype49, $_size46);
                        for ($_i50 = 0; $_i50 < $_size46; ++$_i50) {
                            $elem51 = null;
                            $elem51 = new \EDAM\Types\Resource();
                            $xfer += $elem51->read($input);
                            $this->resources []= $elem51;
                        }
                        $xfer += $input->readListEnd();
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 14:
                    if ($ftype == TType::STRUCT) {
                        $this->attributes = new \EDAM\Types\NoteAttributes();
                        $xfer += $this->attributes->read($input);
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 15:
                    if ($ftype == TType::LST) {
                        $this->tagNames = array();
                        $_size52 = 0;
                        $_etype55 = 0;
                        $xfer += $input->readListBegin($_etype55, $_size52);
                        for ($_i56 = 0; $_i56 < $_size52; ++$_i56) {
                            $elem57 = null;
                            $xfer += $input->readString($elem57);
                            $this->tagNames []= $elem57;
                        }
                        $xfer += $input->readListEnd();
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 16:
                    if ($ftype == TType::LST) {
                        $this->sharedNotes = array();
                        $_size58 = 0;
                        $_etype61 = 0;
                        $xfer += $input->readListBegin($_etype61, $_size58);
                        for ($_i62 = 0; $_i62 < $_size58; ++$_i62) {
                            $elem63 = null;
                            $elem63 = new \EDAM\Types\SharedNote();
                            $xfer += $elem63->read($input);
                            $this->sharedNotes []= $elem63;
                        }
                        $xfer += $input->readListEnd();
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 17:
                    if ($ftype == TType::STRUCT) {
                        $this->restrictions = new \EDAM\Types\NoteRestrictions();
                        $xfer += $this->restrictions->read($input);
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 18:
                    if ($ftype == TType::STRUCT) {
                        $this->limits = new \EDAM\Types\NoteLimits();
                        $xfer += $this->limits->read($input);
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                default:
                    $xfer += $input->skip($ftype);
                    break;
            }
            $xfer += $input->readFieldEnd();
        }
        $xfer += $input->readStructEnd();
        return $xfer;
    }

    public function write($output)
    {
        $xfer = 0;
        $xfer += $output->writeStructBegin('Note');
        if ($this->guid !== null) {
            $xfer += $output->writeFieldBegin('guid', TType::STRING, 1);
            $xfer += $output->writeString($this->guid);
            $xfer += $output->writeFieldEnd();
        }
        if ($this->title !== null) {
            $xfer += $output->writeFieldBegin('title', TType::STRING, 2);
            $xfer += $output->writeString($this->title);
            $xfer += $output->writeFieldEnd();
        }
        if ($this->content !== null) {
            $xfer += $output->writeFieldBegin('content', TType::STRING, 3);
            $xfer += $output->writeString($this->content);
            $xfer += $output->writeFieldEnd();
        }
        if ($this->contentHash !== null) {
            $xfer += $output->writeFieldBegin('contentHash', TType::STRING, 4);
            $xfer += $output->writeString($this->contentHash);
            $xfer += $output->writeFieldEnd();
        }
        if ($this->contentLength !== null) {
            $xfer += $output->writeFieldBegin('contentLength', TType::I32, 5);
            $xfer += $output->writeI32($this->contentLength);
            $xfer += $output->writeFieldEnd();
        }
        if ($this->created !== null) {
            $xfer += $output->writeFieldBegin('created', TType::I64, 6);
            $xfer += $output->writeI64($this->created);
            $xfer += $output->writeFieldEnd();
        }
        if ($this->updated !== null) {
            $xfer += $output->writeFieldBegin('updated', TType::I64, 7);
            $xfer += $output->writeI64($this->updated);
            $xfer += $output->writeFieldEnd();
        }
        if ($this->deleted !== null) {
            $xfer += $output->writeFieldBegin('deleted', TType::I64, 8);
            $xfer += $output->writeI64($this->deleted);
            $xfer += $output->writeFieldEnd();
        }
        if ($this->active !== null) {
            $xfer += $output->writeFieldBegin('active', TType::BOOL, 9);
            $xfer += $output->writeBool($this->active);
            $xfer += $output->writeFieldEnd();
        }
        if ($this->updateSequenceNum !== null) {
            $xfer += $output->writeFieldBegin('updateSequenceNum', TType::I32, 10);
            $xfer += $output->writeI32($this->updateSequenceNum);
            $xfer += $output->writeFieldEnd();
        }
        if ($this->notebookGuid !== null) {
            $xfer += $output->writeFieldBegin('notebookGuid', TType::STRING, 11);
            $xfer += $output->writeString($this->notebookGuid);
            $xfer += $output->writeFieldEnd();
        }
        if ($this->tagGuids !== null) {
            if (!is_array($this->tagGuids)) {
                throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
            }
            $xfer += $output->writeFieldBegin('tagGuids', TType::LST, 12);
            $output->writeListBegin(TType::STRING, count($this->tagGuids));
            foreach ($this->tagGuids as $iter64) {
                $xfer += $output->writeString($iter64);
            }
            $output->writeListEnd();
            $xfer += $output->writeFieldEnd();
        }
        if ($this->resources !== null) {
            if (!is_array($this->resources)) {
                throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
            }
            $xfer += $output->writeFieldBegin('resources', TType::LST, 13);
            $output->writeListBegin(TType::STRUCT, count($this->resources));
            foreach ($this->resources as $iter65) {
                $xfer += $iter65->write($output);
            }
            $output->writeListEnd();
            $xfer += $output->writeFieldEnd();
        }
        if ($this->attributes !== null) {
            if (!is_object($this->attributes)) {
                throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
            }
            $xfer += $output->writeFieldBegin('attributes', TType::STRUCT, 14);
            $xfer += $this->attributes->write($output);
            $xfer += $output->writeFieldEnd();
        }
        if ($this->tagNames !== null) {
            if (!is_array($this->tagNames)) {
                throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
            }
            $xfer += $output->writeFieldBegin('tagNames', TType::LST, 15);
            $output->writeListBegin(TType::STRING, count($this->tagNames));
            foreach ($this->tagNames as $iter66) {
                $xfer += $output->writeString($iter66);
            }
            $output->writeListEnd();
            $xfer += $output->writeFieldEnd();
        }
        if ($this->sharedNotes !== null) {
            if (!is_array($this->sharedNotes)) {
                throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
            }
            $xfer += $output->writeFieldBegin('sharedNotes', TType::LST, 16);
            $output->writeListBegin(TType::STRUCT, count($this->sharedNotes));
            foreach ($this->sharedNotes as $iter67) {
                $xfer += $iter67->write($output);
            }
            $output->writeListEnd();
            $xfer += $output->writeFieldEnd();
        }
        if ($this->restrictions !== null) {
            if (!is_object($this->restrictions)) {
                throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
            }
            $xfer += $output->writeFieldBegin('restrictions', TType::STRUCT, 17);
            $xfer += $this->restrictions->write($output);
            $xfer += $output->writeFieldEnd();
        }
        if ($this->limits !== null) {
            if (!is_object($this->limits)) {
                throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
            }
            $xfer += $output->writeFieldBegin('limits', TType::STRUCT, 18);
            $xfer += $this->limits->write($output);
            $xfer += $output->writeFieldEnd();
        }
        $xfer += $output->writeFieldStop();
        $xfer += $output->writeStructEnd();
        return $xfer;
    }
}

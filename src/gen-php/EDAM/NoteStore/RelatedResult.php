<?php
namespace EDAM\NoteStore;

/**
 * Autogenerated by Thrift Compiler (0.21.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
use Thrift\Base\TBase;
use Thrift\Type\TType;
use Thrift\Type\TMessageType;
use Thrift\Exception\TException;
use Thrift\Exception\TProtocolException;
use Thrift\Protocol\TProtocol;
use Thrift\Protocol\TBinaryProtocolAccelerated;
use Thrift\Exception\TApplicationException;

/**
 * The result of calling findRelated().  The contents of the notes,
 * notebooks, and tags fields will be in decreasing order of expected
 * relevance.  It is possible that fewer results than requested will be
 * returned even if there are enough distinct entities in the account
 * in cases where the relevance is estimated to be low.
 * 
 * <dl>
 * <dt>notes</dt>
 * <dd>If notes have been requested to be included, this will be the
 *     list of notes.</dd>
 * 
 * <dt>notebooks</dt>
 * <dd>If notebooks have been requested to be included, this will be the
 *     list of notebooks.</dd>
 * 
 * <dt>tags</dt>
 * <dd>If tags have been requested to be included, this will be the list
 *     of tags.</dd>
 * 
 * <dt>containingNotebooks</dt>
 * <dd>If <code>includeContainingNotebooks</code> is set to <code>true</code>
 *     in the RelatedResultSpec, return the list of notebooks to
 *     to which the returned related notes belong. The notebooks in this
 *     list will occur once per notebook GUID and are represented as
 *     NotebookDescriptor objects.</dd>
 * 
 * <dt>experts</dt>
 * <dd>If experts have been requested to be included, this will return
 *  a list of users within your business who have knowledge about the specified query.
 * </dd>
 * 
 * <dt>relatedContent</dt>
 * <dd>If related content has been requested to be included, this will be the list of
 *  related content snippets.
 * </dd>
 * 
 * <dt>cacheKey</dt>
 * <dd>If set and non-empty, this cache key may be used in subsequent
 *     "NoteStore.findRelated" calls (via "RelatedQuery") to re-use previous
 *     responses that were cached on the client-side, instead of actually performing
 *     another search.
 * 
 *     If set to an empty string, this indicates that the server could not determine
 *     a specific key for this response, but the client should nevertheless remove
 *     any previously cached result for this request.
 * 
 *     If unset/null, it is up to the client whether to re-use cached results or to
 *     use the server's response.
 * 
 *     If set to the exact non-empty cache key that was specified in
 *     "RelatedQuery.cacheKey", this indicates that the server decided that cached results
 *     could be reused.
 * 
 *     Depending on the cache key specified in the query, the "RelatedResult" may only be
 *     partially filled. For each set field, the client should replace the corresponding
 *     part in the previously cached result with the new partial result.
 * 
 *     For example, for a specific query that has both "RelatedResultSpec.maxNotes" and
 *     "RelatedResultSpec.maxRelatedContent" set to positive values, the server may decide
 *     that the previously requested and cached <em>Related Content</em> are unchanged,
 *     but new results for <em>Related Notes</em> are available. The
 *     response will have a new cache key and have "RelatedResult.notes" set, but have
 *     "RelatedResult.relatedContent" unset (not just empty, but really unset).
 * 
 *     In this situation, the client should replace any cached notes with the newly
 *     returned "RelatedResult.notes", but it can re-use the previously cached entries for
 *     "RelatedResult.relatedContent". List fields that are set, but empty indicate that
 *     no results could be found; the cache should be updated correspondingly.
 * </dd>
 * 
 * <dt>cacheExpires</dt>
 * <dd> If set, clients should reuse this response for any situations where the same input
 *      parameters are applicable for up to this many seconds after receiving this result.
 * 
 *      After this time has passed, the client may request a new result from the service,
 *      but it should supply the stored cacheKey to the service when checking for an
 *      update.
 * </dd>
 * 
 * </dl>
 */
class RelatedResult
{
    static public $isValidate = false;

    static public $_TSPEC = array(
        1 => array(
            'var' => 'notes',
            'isRequired' => false,
            'type' => TType::LST,
            'etype' => TType::STRUCT,
            'elem' => array(
                'type' => TType::STRUCT,
                'class' => '\EDAM\Types\Note',
                ),
        ),
        2 => array(
            'var' => 'notebooks',
            'isRequired' => false,
            'type' => TType::LST,
            'etype' => TType::STRUCT,
            'elem' => array(
                'type' => TType::STRUCT,
                'class' => '\EDAM\Types\Notebook',
                ),
        ),
        3 => array(
            'var' => 'tags',
            'isRequired' => false,
            'type' => TType::LST,
            'etype' => TType::STRUCT,
            'elem' => array(
                'type' => TType::STRUCT,
                'class' => '\EDAM\Types\Tag',
                ),
        ),
        4 => array(
            'var' => 'containingNotebooks',
            'isRequired' => false,
            'type' => TType::LST,
            'etype' => TType::STRUCT,
            'elem' => array(
                'type' => TType::STRUCT,
                'class' => '\EDAM\Types\NotebookDescriptor',
                ),
        ),
        5 => array(
            'var' => 'debugInfo',
            'isRequired' => false,
            'type' => TType::STRING,
        ),
        6 => array(
            'var' => 'experts',
            'isRequired' => false,
            'type' => TType::LST,
            'etype' => TType::STRUCT,
            'elem' => array(
                'type' => TType::STRUCT,
                'class' => '\EDAM\Types\UserProfile',
                ),
        ),
        7 => array(
            'var' => 'relatedContent',
            'isRequired' => false,
            'type' => TType::LST,
            'etype' => TType::STRUCT,
            'elem' => array(
                'type' => TType::STRUCT,
                'class' => '\EDAM\Types\RelatedContent',
                ),
        ),
        8 => array(
            'var' => 'cacheKey',
            'isRequired' => false,
            'type' => TType::STRING,
        ),
        9 => array(
            'var' => 'cacheExpires',
            'isRequired' => false,
            'type' => TType::I32,
        ),
    );

    /**
     * @var \EDAM\Types\Note[]
     */
    public $notes = null;
    /**
     * @var \EDAM\Types\Notebook[]
     */
    public $notebooks = null;
    /**
     * @var \EDAM\Types\Tag[]
     */
    public $tags = null;
    /**
     * @var \EDAM\Types\NotebookDescriptor[]
     */
    public $containingNotebooks = null;
    /**
     * @var string
     */
    public $debugInfo = null;
    /**
     * @var \EDAM\Types\UserProfile[]
     */
    public $experts = null;
    /**
     * @var \EDAM\Types\RelatedContent[]
     */
    public $relatedContent = null;
    /**
     * @var string
     */
    public $cacheKey = null;
    /**
     * @var int
     */
    public $cacheExpires = null;

    public function __construct($vals = null)
    {
        if (is_array($vals)) {
            if (isset($vals['notes'])) {
                $this->notes = $vals['notes'];
            }
            if (isset($vals['notebooks'])) {
                $this->notebooks = $vals['notebooks'];
            }
            if (isset($vals['tags'])) {
                $this->tags = $vals['tags'];
            }
            if (isset($vals['containingNotebooks'])) {
                $this->containingNotebooks = $vals['containingNotebooks'];
            }
            if (isset($vals['debugInfo'])) {
                $this->debugInfo = $vals['debugInfo'];
            }
            if (isset($vals['experts'])) {
                $this->experts = $vals['experts'];
            }
            if (isset($vals['relatedContent'])) {
                $this->relatedContent = $vals['relatedContent'];
            }
            if (isset($vals['cacheKey'])) {
                $this->cacheKey = $vals['cacheKey'];
            }
            if (isset($vals['cacheExpires'])) {
                $this->cacheExpires = $vals['cacheExpires'];
            }
        }
    }

    public function getName()
    {
        return 'RelatedResult';
    }


    public function read($input)
    {
        $xfer = 0;
        $fname = null;
        $ftype = 0;
        $fid = 0;
        $xfer += $input->readStructBegin($fname);
        while (true) {
            $xfer += $input->readFieldBegin($fname, $ftype, $fid);
            if ($ftype == TType::STOP) {
                break;
            }
            switch ($fid) {
                case 1:
                    if ($ftype == TType::LST) {
                        $this->notes = array();
                        $_size173 = 0;
                        $_etype176 = 0;
                        $xfer += $input->readListBegin($_etype176, $_size173);
                        for ($_i177 = 0; $_i177 < $_size173; ++$_i177) {
                            $elem178 = null;
                            $elem178 = new \EDAM\Types\Note();
                            $xfer += $elem178->read($input);
                            $this->notes []= $elem178;
                        }
                        $xfer += $input->readListEnd();
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 2:
                    if ($ftype == TType::LST) {
                        $this->notebooks = array();
                        $_size179 = 0;
                        $_etype182 = 0;
                        $xfer += $input->readListBegin($_etype182, $_size179);
                        for ($_i183 = 0; $_i183 < $_size179; ++$_i183) {
                            $elem184 = null;
                            $elem184 = new \EDAM\Types\Notebook();
                            $xfer += $elem184->read($input);
                            $this->notebooks []= $elem184;
                        }
                        $xfer += $input->readListEnd();
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 3:
                    if ($ftype == TType::LST) {
                        $this->tags = array();
                        $_size185 = 0;
                        $_etype188 = 0;
                        $xfer += $input->readListBegin($_etype188, $_size185);
                        for ($_i189 = 0; $_i189 < $_size185; ++$_i189) {
                            $elem190 = null;
                            $elem190 = new \EDAM\Types\Tag();
                            $xfer += $elem190->read($input);
                            $this->tags []= $elem190;
                        }
                        $xfer += $input->readListEnd();
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 4:
                    if ($ftype == TType::LST) {
                        $this->containingNotebooks = array();
                        $_size191 = 0;
                        $_etype194 = 0;
                        $xfer += $input->readListBegin($_etype194, $_size191);
                        for ($_i195 = 0; $_i195 < $_size191; ++$_i195) {
                            $elem196 = null;
                            $elem196 = new \EDAM\Types\NotebookDescriptor();
                            $xfer += $elem196->read($input);
                            $this->containingNotebooks []= $elem196;
                        }
                        $xfer += $input->readListEnd();
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 5:
                    if ($ftype == TType::STRING) {
                        $xfer += $input->readString($this->debugInfo);
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 6:
                    if ($ftype == TType::LST) {
                        $this->experts = array();
                        $_size197 = 0;
                        $_etype200 = 0;
                        $xfer += $input->readListBegin($_etype200, $_size197);
                        for ($_i201 = 0; $_i201 < $_size197; ++$_i201) {
                            $elem202 = null;
                            $elem202 = new \EDAM\Types\UserProfile();
                            $xfer += $elem202->read($input);
                            $this->experts []= $elem202;
                        }
                        $xfer += $input->readListEnd();
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 7:
                    if ($ftype == TType::LST) {
                        $this->relatedContent = array();
                        $_size203 = 0;
                        $_etype206 = 0;
                        $xfer += $input->readListBegin($_etype206, $_size203);
                        for ($_i207 = 0; $_i207 < $_size203; ++$_i207) {
                            $elem208 = null;
                            $elem208 = new \EDAM\Types\RelatedContent();
                            $xfer += $elem208->read($input);
                            $this->relatedContent []= $elem208;
                        }
                        $xfer += $input->readListEnd();
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 8:
                    if ($ftype == TType::STRING) {
                        $xfer += $input->readString($this->cacheKey);
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 9:
                    if ($ftype == TType::I32) {
                        $xfer += $input->readI32($this->cacheExpires);
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                default:
                    $xfer += $input->skip($ftype);
                    break;
            }
            $xfer += $input->readFieldEnd();
        }
        $xfer += $input->readStructEnd();
        return $xfer;
    }

    public function write($output)
    {
        $xfer = 0;
        $xfer += $output->writeStructBegin('RelatedResult');
        if ($this->notes !== null) {
            if (!is_array($this->notes)) {
                throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
            }
            $xfer += $output->writeFieldBegin('notes', TType::LST, 1);
            $output->writeListBegin(TType::STRUCT, count($this->notes));
            foreach ($this->notes as $iter209) {
                $xfer += $iter209->write($output);
            }
            $output->writeListEnd();
            $xfer += $output->writeFieldEnd();
        }
        if ($this->notebooks !== null) {
            if (!is_array($this->notebooks)) {
                throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
            }
            $xfer += $output->writeFieldBegin('notebooks', TType::LST, 2);
            $output->writeListBegin(TType::STRUCT, count($this->notebooks));
            foreach ($this->notebooks as $iter210) {
                $xfer += $iter210->write($output);
            }
            $output->writeListEnd();
            $xfer += $output->writeFieldEnd();
        }
        if ($this->tags !== null) {
            if (!is_array($this->tags)) {
                throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
            }
            $xfer += $output->writeFieldBegin('tags', TType::LST, 3);
            $output->writeListBegin(TType::STRUCT, count($this->tags));
            foreach ($this->tags as $iter211) {
                $xfer += $iter211->write($output);
            }
            $output->writeListEnd();
            $xfer += $output->writeFieldEnd();
        }
        if ($this->containingNotebooks !== null) {
            if (!is_array($this->containingNotebooks)) {
                throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
            }
            $xfer += $output->writeFieldBegin('containingNotebooks', TType::LST, 4);
            $output->writeListBegin(TType::STRUCT, count($this->containingNotebooks));
            foreach ($this->containingNotebooks as $iter212) {
                $xfer += $iter212->write($output);
            }
            $output->writeListEnd();
            $xfer += $output->writeFieldEnd();
        }
        if ($this->debugInfo !== null) {
            $xfer += $output->writeFieldBegin('debugInfo', TType::STRING, 5);
            $xfer += $output->writeString($this->debugInfo);
            $xfer += $output->writeFieldEnd();
        }
        if ($this->experts !== null) {
            if (!is_array($this->experts)) {
                throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
            }
            $xfer += $output->writeFieldBegin('experts', TType::LST, 6);
            $output->writeListBegin(TType::STRUCT, count($this->experts));
            foreach ($this->experts as $iter213) {
                $xfer += $iter213->write($output);
            }
            $output->writeListEnd();
            $xfer += $output->writeFieldEnd();
        }
        if ($this->relatedContent !== null) {
            if (!is_array($this->relatedContent)) {
                throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
            }
            $xfer += $output->writeFieldBegin('relatedContent', TType::LST, 7);
            $output->writeListBegin(TType::STRUCT, count($this->relatedContent));
            foreach ($this->relatedContent as $iter214) {
                $xfer += $iter214->write($output);
            }
            $output->writeListEnd();
            $xfer += $output->writeFieldEnd();
        }
        if ($this->cacheKey !== null) {
            $xfer += $output->writeFieldBegin('cacheKey', TType::STRING, 8);
            $xfer += $output->writeString($this->cacheKey);
            $xfer += $output->writeFieldEnd();
        }
        if ($this->cacheExpires !== null) {
            $xfer += $output->writeFieldBegin('cacheExpires', TType::I32, 9);
            $xfer += $output->writeI32($this->cacheExpires);
            $xfer += $output->writeFieldEnd();
        }
        $xfer += $output->writeFieldStop();
        $xfer += $output->writeStructEnd();
        return $xfer;
    }
}

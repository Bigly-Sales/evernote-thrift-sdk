<?php
namespace EDAM\NoteStore;

/**
 * Autogenerated by Thrift Compiler (0.21.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
use Thrift\Base\TBase;
use Thrift\Type\TType;
use Thrift\Type\TMessageType;
use Thrift\Exception\TException;
use Thrift\Exception\TProtocolException;
use Thrift\Protocol\TProtocol;
use Thrift\Protocol\TBinaryProtocolAccelerated;
use Thrift\Exception\TApplicationException;

/**
 * A description of the thing for which the service will find related
 * entities, via findRelated(), together with a description of what
 * type of entities and how many you are seeking in the
 * RelatedResult.
 * 
 * <dl>
 * <dt>maxNotes</dt>
 * <dd>Return notes that are related to the query, but no more than
 *     this many.  Any value greater than EDAM_RELATED_MAX_NOTES
 *     will be silently capped.  If you do not set this field, then
 *     no notes will be returned.</dd>
 * 
 * <dt>maxNotebooks</dt>
 * <dd>Return notebooks that are related to the query, but no more than
 *     this many.  Any value greater than EDAM_RELATED_MAX_NOTEBOOKS
 *     will be silently capped.  If you do not set this field, then
 *     no notebooks will be returned.</dd>
 * 
 * <dt>maxTags</dt>
 * <dd>Return tags that are related to the query, but no more than
 *     this many.  Any value greater than EDAM_RELATED_MAX_TAGS
 *     will be silently capped.  If you do not set this field, then
 *     no tags will be returned.</dd>
 * </dl>
 * 
 * <dt>writableNotebooksOnly</dt>
 * <dd>Require that all returned related notebooks are writable.
 *     The user will be able to create notes in all returned notebooks.
 *     However, individual notes returned may still belong to notebooks
 *     in which the user lacks the ability to create notes.</dd>
 * </dl>
 * 
 * <dt>includeContainingNotebooks</dt>
 * <dd>If set to <code>true</code>, return the containingNotebooks field
 *     in the RelatedResult, which will contain the list of notebooks to
 *     to which the returned related notes belong.</dd>
 * </dl>
 * 
 * <dt>includeDebugInfo</dt>
 * <dd>If set to <code>true</code>, indicate that debug information should
 *     be returned in the 'debugInfo' field of RelatedResult. Note that the call may
 *     be slower if this flag is set.</dd>
 * 
 * <dt>maxExperts</dt>
 * <dd>This can only be used when making a findRelated call against a business.
 *  Find users within your business who have knowledge about the specified query.
 *  No more than this many users will be returned. Any value greater than
 *  EDAM_RELATED_MAX_EXPERTS will be silently capped.
 * </dd>
 * 
 * <dt>maxRelatedContent</dt>
 * <dd>Return snippets of related content that is related to the query, but no more than
 *  this many. Any value greater than EDAM_RELATED_MAX_RELATED_CONTENT will be silently
 *  capped. If you do not set this field, then no related content will be returned.</dd>
 * </dl>
 * 
 * <dt>relatedContentTypes</dt>
 * <dd>Specifies the types of Related Content that should be returned.</dd>
 * </dl>
 */
class RelatedResultSpec
{
    static public $isValidate = false;

    static public $_TSPEC = array(
        1 => array(
            'var' => 'maxNotes',
            'isRequired' => false,
            'type' => TType::I32,
        ),
        2 => array(
            'var' => 'maxNotebooks',
            'isRequired' => false,
            'type' => TType::I32,
        ),
        3 => array(
            'var' => 'maxTags',
            'isRequired' => false,
            'type' => TType::I32,
        ),
        4 => array(
            'var' => 'writableNotebooksOnly',
            'isRequired' => false,
            'type' => TType::BOOL,
        ),
        5 => array(
            'var' => 'includeContainingNotebooks',
            'isRequired' => false,
            'type' => TType::BOOL,
        ),
        6 => array(
            'var' => 'includeDebugInfo',
            'isRequired' => false,
            'type' => TType::BOOL,
        ),
        7 => array(
            'var' => 'maxExperts',
            'isRequired' => false,
            'type' => TType::I32,
        ),
        8 => array(
            'var' => 'maxRelatedContent',
            'isRequired' => false,
            'type' => TType::I32,
        ),
        9 => array(
            'var' => 'relatedContentTypes',
            'isRequired' => false,
            'type' => TType::SET,
            'etype' => TType::I32,
            'elem' => array(
                'type' => TType::I32,
                'class' => '\EDAM\Types\RelatedContentType',
                ),
        ),
    );

    /**
     * @var int
     */
    public $maxNotes = null;
    /**
     * @var int
     */
    public $maxNotebooks = null;
    /**
     * @var int
     */
    public $maxTags = null;
    /**
     * @var bool
     */
    public $writableNotebooksOnly = null;
    /**
     * @var bool
     */
    public $includeContainingNotebooks = null;
    /**
     * @var bool
     */
    public $includeDebugInfo = null;
    /**
     * @var int
     */
    public $maxExperts = null;
    /**
     * @var int
     */
    public $maxRelatedContent = null;
    /**
     * @var int[]
     */
    public $relatedContentTypes = null;

    public function __construct($vals = null)
    {
        if (is_array($vals)) {
            if (isset($vals['maxNotes'])) {
                $this->maxNotes = $vals['maxNotes'];
            }
            if (isset($vals['maxNotebooks'])) {
                $this->maxNotebooks = $vals['maxNotebooks'];
            }
            if (isset($vals['maxTags'])) {
                $this->maxTags = $vals['maxTags'];
            }
            if (isset($vals['writableNotebooksOnly'])) {
                $this->writableNotebooksOnly = $vals['writableNotebooksOnly'];
            }
            if (isset($vals['includeContainingNotebooks'])) {
                $this->includeContainingNotebooks = $vals['includeContainingNotebooks'];
            }
            if (isset($vals['includeDebugInfo'])) {
                $this->includeDebugInfo = $vals['includeDebugInfo'];
            }
            if (isset($vals['maxExperts'])) {
                $this->maxExperts = $vals['maxExperts'];
            }
            if (isset($vals['maxRelatedContent'])) {
                $this->maxRelatedContent = $vals['maxRelatedContent'];
            }
            if (isset($vals['relatedContentTypes'])) {
                $this->relatedContentTypes = $vals['relatedContentTypes'];
            }
        }
    }

    public function getName()
    {
        return 'RelatedResultSpec';
    }


    public function read($input)
    {
        $xfer = 0;
        $fname = null;
        $ftype = 0;
        $fid = 0;
        $xfer += $input->readStructBegin($fname);
        while (true) {
            $xfer += $input->readFieldBegin($fname, $ftype, $fid);
            if ($ftype == TType::STOP) {
                break;
            }
            switch ($fid) {
                case 1:
                    if ($ftype == TType::I32) {
                        $xfer += $input->readI32($this->maxNotes);
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 2:
                    if ($ftype == TType::I32) {
                        $xfer += $input->readI32($this->maxNotebooks);
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 3:
                    if ($ftype == TType::I32) {
                        $xfer += $input->readI32($this->maxTags);
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 4:
                    if ($ftype == TType::BOOL) {
                        $xfer += $input->readBool($this->writableNotebooksOnly);
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 5:
                    if ($ftype == TType::BOOL) {
                        $xfer += $input->readBool($this->includeContainingNotebooks);
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 6:
                    if ($ftype == TType::BOOL) {
                        $xfer += $input->readBool($this->includeDebugInfo);
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 7:
                    if ($ftype == TType::I32) {
                        $xfer += $input->readI32($this->maxExperts);
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 8:
                    if ($ftype == TType::I32) {
                        $xfer += $input->readI32($this->maxRelatedContent);
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 9:
                    if ($ftype == TType::SET) {
                        $this->relatedContentTypes = array();
                        $_size215 = 0;
                        $_etype218 = 0;
                        $xfer += $input->readSetBegin($_etype218, $_size215);
                        for ($_i219 = 0; $_i219 < $_size215; ++$_i219) {
                            $elem220 = null;
                            $xfer += $input->readI32($elem220);
                            $this->relatedContentTypes[$elem220] = true;
                        }
                        $xfer += $input->readSetEnd();
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                default:
                    $xfer += $input->skip($ftype);
                    break;
            }
            $xfer += $input->readFieldEnd();
        }
        $xfer += $input->readStructEnd();
        return $xfer;
    }

    public function write($output)
    {
        $xfer = 0;
        $xfer += $output->writeStructBegin('RelatedResultSpec');
        if ($this->maxNotes !== null) {
            $xfer += $output->writeFieldBegin('maxNotes', TType::I32, 1);
            $xfer += $output->writeI32($this->maxNotes);
            $xfer += $output->writeFieldEnd();
        }
        if ($this->maxNotebooks !== null) {
            $xfer += $output->writeFieldBegin('maxNotebooks', TType::I32, 2);
            $xfer += $output->writeI32($this->maxNotebooks);
            $xfer += $output->writeFieldEnd();
        }
        if ($this->maxTags !== null) {
            $xfer += $output->writeFieldBegin('maxTags', TType::I32, 3);
            $xfer += $output->writeI32($this->maxTags);
            $xfer += $output->writeFieldEnd();
        }
        if ($this->writableNotebooksOnly !== null) {
            $xfer += $output->writeFieldBegin('writableNotebooksOnly', TType::BOOL, 4);
            $xfer += $output->writeBool($this->writableNotebooksOnly);
            $xfer += $output->writeFieldEnd();
        }
        if ($this->includeContainingNotebooks !== null) {
            $xfer += $output->writeFieldBegin('includeContainingNotebooks', TType::BOOL, 5);
            $xfer += $output->writeBool($this->includeContainingNotebooks);
            $xfer += $output->writeFieldEnd();
        }
        if ($this->includeDebugInfo !== null) {
            $xfer += $output->writeFieldBegin('includeDebugInfo', TType::BOOL, 6);
            $xfer += $output->writeBool($this->includeDebugInfo);
            $xfer += $output->writeFieldEnd();
        }
        if ($this->maxExperts !== null) {
            $xfer += $output->writeFieldBegin('maxExperts', TType::I32, 7);
            $xfer += $output->writeI32($this->maxExperts);
            $xfer += $output->writeFieldEnd();
        }
        if ($this->maxRelatedContent !== null) {
            $xfer += $output->writeFieldBegin('maxRelatedContent', TType::I32, 8);
            $xfer += $output->writeI32($this->maxRelatedContent);
            $xfer += $output->writeFieldEnd();
        }
        if ($this->relatedContentTypes !== null) {
            if (!is_array($this->relatedContentTypes)) {
                throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
            }
            $xfer += $output->writeFieldBegin('relatedContentTypes', TType::SET, 9);
            $output->writeSetBegin(TType::I32, count($this->relatedContentTypes));
            foreach ($this->relatedContentTypes as $iter221 => $iter222) {
                $xfer += $output->writeI32($iter221);
            }
            $output->writeSetEnd();
            $xfer += $output->writeFieldEnd();
        }
        $xfer += $output->writeFieldStop();
        $xfer += $output->writeStructEnd();
        return $xfer;
    }
}

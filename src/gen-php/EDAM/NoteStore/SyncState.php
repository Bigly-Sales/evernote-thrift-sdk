<?php
namespace EDAM\NoteStore;

/**
 * Autogenerated by Thrift Compiler (0.21.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
use Thrift\Base\TBase;
use Thrift\Type\TType;
use Thrift\Type\TMessageType;
use Thrift\Exception\TException;
use Thrift\Exception\TProtocolException;
use Thrift\Protocol\TProtocol;
use Thrift\Protocol\TBinaryProtocolAccelerated;
use Thrift\Exception\TApplicationException;

/**
 * This structure encapsulates the information about the state of the
 * user's account for the purpose of "state based" synchronization.
 * <dl>
 * <dt>currentTime</dt>
 *   <dd>
 *   The server's current date and time.
 *   </dd>
 * <dt>fullSyncBefore</dt>
 *   <dd>
 *   The cutoff date and time for client caches to be
 *   updated via incremental synchronization.  Any clients that were last
 *   synched with the server before this date/time must do a full resync of all
 *   objects.  This cutoff point will change over time as archival data is
 *   deleted or special circumstances on the service require resynchronization.
 *   </dd>
 * <dt>updateCount</dt>
 *   <dd>
 *   Indicates the total number of transactions that have
 *   been committed within the account.  This reflects (for example) the
 *   number of discrete additions or modifications that have been made to
 *   the data in this account (tags, notes, resources, etc.).
 *   This number is the "high water mark" for Update Sequence Numbers (USN)
 *   within the account.
 *   </dd>
 * <dt>uploaded</dt>
 *   <dd>
 *   The total number of bytes that have been uploaded to
 *   this account in the current monthly period.  This can be compared against
 *   Accounting.uploadLimit (from the UserStore) to determine how close the user
 *   is to their monthly upload limit.
 *   This value may not be present if the SyncState has been retrieved by
 *   a caller that only has read access to the account.
 *   </dd>
 * <dt>userLastUpdated</dt>
 *   <dd>
 *   The last time when a user's account level information was changed. This value
 *   is the latest time when a modification was made to any of the following:
 *   accounting information (billing, quota, premium status, etc.), user attributes
 *   and business user information (business name, business user attributes, etc.) if
 *   the user is in a business.
 *   Clients who need to maintain account information about a User should watch this
 *   field for updates rather than polling UserStore.getUser for updates. Here is the
 *   basic flow that clients should follow:
 *   <ol>
 *     <li>Call NoteStore.getSyncState to retrieve the SyncState object</li>
 *     <li>Compare SyncState.userLastUpdated to previously stored value:
 *         if (SyncState.userLastUpdated > previousValue)
 *           call UserStore.getUser to get the latest User object;
 *         else
 *           do nothing;</li>
 *     <li>Update previousValue = SyncState.userLastUpdated</li>
 *   </ol>
 *   </dd>
 * <dt>userMaxMessageEventId</dt>
 *   <dd>
 *   The greatest MessageEventID for this user's account. Clients that do a full
 *   sync should store this value locally and compare their local copy to the
 *   value returned by getSyncState to determine if they need to sync with
 *   MessageStore. This value will be omitted if the user has never sent or
 *   received a message.
 *   </dd>
 * </dl>
 */
class SyncState
{
    static public $isValidate = false;

    static public $_TSPEC = array(
        1 => array(
            'var' => 'currentTime',
            'isRequired' => true,
            'type' => TType::I64,
        ),
        2 => array(
            'var' => 'fullSyncBefore',
            'isRequired' => true,
            'type' => TType::I64,
        ),
        3 => array(
            'var' => 'updateCount',
            'isRequired' => true,
            'type' => TType::I32,
        ),
        4 => array(
            'var' => 'uploaded',
            'isRequired' => false,
            'type' => TType::I64,
        ),
        5 => array(
            'var' => 'userLastUpdated',
            'isRequired' => false,
            'type' => TType::I64,
        ),
        6 => array(
            'var' => 'userMaxMessageEventId',
            'isRequired' => false,
            'type' => TType::I64,
        ),
    );

    /**
     * @var int
     */
    public $currentTime = null;
    /**
     * @var int
     */
    public $fullSyncBefore = null;
    /**
     * @var int
     */
    public $updateCount = null;
    /**
     * @var int
     */
    public $uploaded = null;
    /**
     * @var int
     */
    public $userLastUpdated = null;
    /**
     * @var int
     */
    public $userMaxMessageEventId = null;

    public function __construct($vals = null)
    {
        if (is_array($vals)) {
            if (isset($vals['currentTime'])) {
                $this->currentTime = $vals['currentTime'];
            }
            if (isset($vals['fullSyncBefore'])) {
                $this->fullSyncBefore = $vals['fullSyncBefore'];
            }
            if (isset($vals['updateCount'])) {
                $this->updateCount = $vals['updateCount'];
            }
            if (isset($vals['uploaded'])) {
                $this->uploaded = $vals['uploaded'];
            }
            if (isset($vals['userLastUpdated'])) {
                $this->userLastUpdated = $vals['userLastUpdated'];
            }
            if (isset($vals['userMaxMessageEventId'])) {
                $this->userMaxMessageEventId = $vals['userMaxMessageEventId'];
            }
        }
    }

    public function getName()
    {
        return 'SyncState';
    }


    public function read($input)
    {
        $xfer = 0;
        $fname = null;
        $ftype = 0;
        $fid = 0;
        $xfer += $input->readStructBegin($fname);
        while (true) {
            $xfer += $input->readFieldBegin($fname, $ftype, $fid);
            if ($ftype == TType::STOP) {
                break;
            }
            switch ($fid) {
                case 1:
                    if ($ftype == TType::I64) {
                        $xfer += $input->readI64($this->currentTime);
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 2:
                    if ($ftype == TType::I64) {
                        $xfer += $input->readI64($this->fullSyncBefore);
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 3:
                    if ($ftype == TType::I32) {
                        $xfer += $input->readI32($this->updateCount);
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 4:
                    if ($ftype == TType::I64) {
                        $xfer += $input->readI64($this->uploaded);
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 5:
                    if ($ftype == TType::I64) {
                        $xfer += $input->readI64($this->userLastUpdated);
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 6:
                    if ($ftype == TType::I64) {
                        $xfer += $input->readI64($this->userMaxMessageEventId);
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                default:
                    $xfer += $input->skip($ftype);
                    break;
            }
            $xfer += $input->readFieldEnd();
        }
        $xfer += $input->readStructEnd();
        return $xfer;
    }

    public function write($output)
    {
        $xfer = 0;
        $xfer += $output->writeStructBegin('SyncState');
        if ($this->currentTime !== null) {
            $xfer += $output->writeFieldBegin('currentTime', TType::I64, 1);
            $xfer += $output->writeI64($this->currentTime);
            $xfer += $output->writeFieldEnd();
        }
        if ($this->fullSyncBefore !== null) {
            $xfer += $output->writeFieldBegin('fullSyncBefore', TType::I64, 2);
            $xfer += $output->writeI64($this->fullSyncBefore);
            $xfer += $output->writeFieldEnd();
        }
        if ($this->updateCount !== null) {
            $xfer += $output->writeFieldBegin('updateCount', TType::I32, 3);
            $xfer += $output->writeI32($this->updateCount);
            $xfer += $output->writeFieldEnd();
        }
        if ($this->uploaded !== null) {
            $xfer += $output->writeFieldBegin('uploaded', TType::I64, 4);
            $xfer += $output->writeI64($this->uploaded);
            $xfer += $output->writeFieldEnd();
        }
        if ($this->userLastUpdated !== null) {
            $xfer += $output->writeFieldBegin('userLastUpdated', TType::I64, 5);
            $xfer += $output->writeI64($this->userLastUpdated);
            $xfer += $output->writeFieldEnd();
        }
        if ($this->userMaxMessageEventId !== null) {
            $xfer += $output->writeFieldBegin('userMaxMessageEventId', TType::I64, 6);
            $xfer += $output->writeI64($this->userMaxMessageEventId);
            $xfer += $output->writeFieldEnd();
        }
        $xfer += $output->writeFieldStop();
        $xfer += $output->writeStructEnd();
        return $xfer;
    }
}
